
var colors = ["#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#8dd3c7", "#ffffb3", "#bebada"];
var barHeight = 100;

var tooltip = d3.select("#barChart")
    .append("div")
    .style("position", "absolute")
    .style("visibility", "hidden");

function createExploit() {
    humanTraffickingData.sort(function (a, b) {
        var textA = a['Type Of Exploitation'];
        var textB = b['Type Of Exploitation'];
        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
    })

    exploit_counts = {};
    // now look at Type of Explotation column, split and find frequency of each type of exploits
    humanTraffickingData.forEach(row => {
        year = row['Year of Registration'];
        if (!exploit_counts[year]) { exploit_counts[year] = {}; }
        splits = row['Type Of Exploitation'].split(";");
        splits.forEach(function (s) {
            // console.log(splits,s);
            if (!exploit_counts[year][s]) {
                // console.log(s);
                exploit_counts[year][s] = 1
            } else {
                // console.log(exploit_counts[s]);
                exploit_counts[year][s]++;
            }
        })
    });//end of forEach for dataset
}

function updateTypoeOfExploit(year, removeAll = false) {
    if (removeAll) {
        svg.selectAll('*').remove();
    }

    createExploit();

    if (year == 'all-years') {
        cur_data = {};
        Object.keys(exploit_counts).forEach(function (year) {
            Object.keys(exploit_counts[year]).forEach(function (type) {
                if (!cur_data[type]) cur_data[type] = exploit_counts[year][type];
                else cur_data[type] = cur_data[type] + exploit_counts[year][type];
            })
        });
        // console.log(cur_data);
    }
    else cur_data = exploit_counts[year];

    exploit_types = Object.keys(cur_data);
    total_count = d3.sum(Object.values(cur_data)); //console.log(total_count)
    var xScale = d3.scaleLinear()
        .domain([0, total_count])
        .range([0, width]);


    // bar chart
    let cumulative = 0;
    var chart = svg.selectAll('.exploit_chart')
        .data(exploit_types);

    var chartEnter = chart.enter()
        .append("rect")
        .attr("class", 'exploit_chart');

    chart.merge(chartEnter)
        .attr("y", height / 2 + barHeight)
        .attr("x", function (d, i) {
            cumulative = cumulative + cur_data[d];
            return xScale(cumulative - cur_data[d]);
        })
        .attr("width", function (d) { return xScale(cur_data[d]); })
        .attr("height", barHeight)

        .style("fill", function (d, i) {
            return colors[i];
        })
        .on("mouseover", typeOfExploitMouseover);


    // type of exploit text labels
    cumulative = 0;
    var exploit_label = svg.selectAll(".exploit_label")
        .data(exploit_types);

    var exploit_lable_enter = exploit_label.enter()
        .append("text")
        .attr("class", "exploit_label")
        //   .attr("text-anchor","middle")
        .text(function (d) { return d; });

    exploit_label.merge(exploit_lable_enter)
        .attr("y", height / 2 + (4.3 * barHeight / 2))
        .attr("x", function (d) {
            cumulative = cumulative + cur_data[d];
            cur_value = cumulative - cur_data[d];
            return xScale(cumulative - cur_data[d]);
        })
        .style("opacity", function (d) {
            if (xScale(cur_data[d]) < 10) {
                return "0";
                ;
            };
        })
        .style("fill", function (d, i) { return colors[i]; });


    // count lables
    cumulative = 0;
    var count_label = svg.selectAll(".count_label")
        .data(exploit_types)

    var count_label_enter = count_label.enter()
        .append("text")
        .attr("class", "count_label")
        .text(function (d) { return cur_data[d]; })
        .style("fill", "#ffffff");

    count_label.merge(count_label_enter)
        .attr("x", function (d) {
            cumulative = cumulative + cur_data[d];
            return xScale(cumulative - cur_data[d]);
        })
        .attr("y", height / 2 + 5 + (3 * barHeight / 2))
        .style("opacity", function (d) {
            if (xScale(cur_data[d]) < 10) {
                return "0";
                ;
            };
        });


    // percent label
    cumulative = 0;
    var percent_label = svg.selectAll(".percent_label")
        .data(exploit_types)

    var percent_label_enter = percent_label.enter()
        .append("text")
        .attr("class", "percent_label");

    percent_label.merge(percent_label_enter)
        .attr("x", function (d) {
            cumulative = cumulative + cur_data[d];
            return xScale(cumulative - cur_data[d]);
        })
        .attr('y', height / 2 + (1.9 * barHeight / 2))
        .style("opacity", function (d) {
            if (xScale(cur_data[d]) < 10) {
                return "0";
                ;
            };
        })
        .text(function (d) {
            val = (cur_data[d] / total_count) * 100;
            return val.toFixed(2) + " %";
        });

    chart.exit().remove();
    exploit_label.exit().remove();
    count_label.exit().remove();
    percent_label.exit().remove();
}

function onToEYearChanged() {
    var select = d3.select('#toe_yearSelector').property('value');

    updateTypoeOfExploit(select);
}

function typeOfExploitMouseover() {
    // console.log(exploit_nestData);
    d3.select(".subChart").remove();
    var exploit_type = d3.select(this)._groups[0][0].id;

    console.log(exploit_type);
    if (exploit_type.includes("sexual") || exploit_type.includes("Sexual")) {
        var extract_dataset = exploit_nestData[exploit_type];
        var nested_extractData = nest_sexType(extract_dataset);
        draw_subChart(nested_extractData);
    }
    else if (exploit_type.includes("labour")) {
        var extract_dataset = exploit_nestData[exploit_type];
        var nested_extractData = nest_labourType(extract_dataset);
        draw_subChart(nested_extractData);
    }
    // console.log(extract_dataset);
}

function draw_subChart(dataset) {
    console.log(dataset);
    var height = 500;
    var color = ['#c51b7d', "#fc9272", '#4d9221', "#3288bd", '#636363', '#756bb1', '#99d8c9', "#d73027", '#fa9fb5', '#7fbc41'];

    var max_width = d3.max(Object.values(dataset), function (d) { return d.length; }); //console.log(max_width);
    var xScale = d3.scaleLinear()
        .domain([0, max_width])//.domain([0,Math.round(max_width/25)*2])//
        .range([0, w]);//.range([0,width]);

    var yScale = d3.scaleBand()
        .domain(Object.keys(dataset))
        .range([0, h])
        .padding(0.01);
    // var band = Math.floor(yScale.bandwidth()); console.log(band);
    //This is how I determined cell size
    var groupSize = 100;
    var nRow = 5;
    var max_cell_num = Math.round(max_width / groupSize); //console.log(max_cell_num)
    var max_col_num = Math.floor(max_cell_num / nRow) + 1;//console.log(max_col_num);

    var new_data = divide_into_group(dataset, max_col_num, groupSize)[0]; //console.log(new_data);
    var svg_subChart = d3.select("body").append("div").attr("class", 'subChart')
        .append("svg").attr("width", width).attr("height", height)
        .attr("transform", "translate(" + -margin.left + "," + 50 + ")");

    var g_label = svg_subChart.append("g")
        .attr("id", "label")
        .attr("transform", "translate(" + 0 + "," + 12 + ")");
    var labels = g_label.selectAll("text")
        .data(divide_into_group(dataset, max_col_num, groupSize)[1])
        .enter()
        .append("text")
        .style("text-anchor", "start")
        // .attr("x",0)
        .attr("y", function (d) { return d.height; })
        .text(function (d) {
            return d.type;
        })

        .style("fill", function (d) {
            var index = Object.keys(dataset).indexOf(d.type);
            return color[index];
        });

    var g_rect = svg_subChart.append("g")
        .attr("id", "sub_rect")
        .attr("transform", "translate(" + 150 + "," + 0 + ")");
    var rects = g_rect.selectAll("rect")
        .data(new_data)
        .enter()
        .append("rect")
        .attr("x", function (d, i) {
            return d.x;
        })
        .attr("y", function (d) {
            return d.y;
        })
        .attr("width", 20)
        .attr("height", 20)
        //.attr("class","subChart_rect")
        .attr("id", function (d) { return d.type; })
        .style("fill", function (d) {
            var index = Object.keys(dataset).indexOf(d.type);
            return color[index];
        });
    var g_legend = svg_subChart.append("g")
        .attr('id', "legend")
        .attr("transform", "translate(" + 860 + "," + 0 + ")");
    ;

    var legends = g_legend.selectAll("rect")
        .data(Object.keys(dataset))
        .enter()
        .append("rect")
        .attr("width", 20)
        .attr("height", 20)
        //    .attr("x",width-20)
        .attr("y", function (d, i) {
            return i * 20 + i * 5;
        })
        .style("fill", function (d) {
            console.log(d);
            var index = Object.keys(dataset).indexOf(d);
            return color[index];
        })
        ;
    var g_legend = svg_subChart.append("g")
        .attr('id', "legend")
        //.attr("transform","translate(" + 650+ ","+0+ ")");
        ;
    var g_legend_text = svg_subChart.append("g")
        .attr('id', "legend_text")
        .attr("transform", "translate(" + 880 + "," + 14 + ")");
    ;
    var legend_texts = g_legend_text.selectAll("text")
        .data(Object.keys(dataset))
        .enter()
        .append("text")
        .style("text-anchor", "start")
        .attr("y", function (d, i) {
            return i * 20 + i * 5;
        })
        .text(function (d) {
            return groupSize + " person";
        })
        .style("fill", function (d) {
            var index = Object.keys(dataset).indexOf(d);
            return color[index];
        })
        ;
}

function divide_into_group(dataset, n_col, groupSize) {
    //bandSize is 123
    var cellSize = 20;
    var gapSize = 5;
    var big_dataset = [];
    var y_gap = 10;
    var cur_height = 0; var next_height = 0;
    var row_info = [];
    Object.keys(dataset).forEach(function (each_type) {
        // console.log(each_type);
        row_info.push({ type: each_type, height: next_height });
        var total_count = dataset[each_type].length; //console.log(each_type, total_count);
        var cur_dataset = [];
        var total_cells = Math.floor(total_count / groupSize) + 1;
        // // console.log(total_cells,groupSize);
        // var n_col = Math.floor(total_cells/nRow)+1; //console.log(total_cells,n_col);
        // var index = Object.keys(dataset).indexOf(each_type);  //console.log(index);
        var n_row = Math.floor(total_cells / n_col) + 1; //console.log(n_row)

        // var cur_y_pos = bandSize*(index);console.log(each_type,cur_y_pos);
        for (var i = 0; i < total_cells; i++) {
            var x = (i % n_col) * cellSize + (i % n_col) * gapSize;
            var y = Math.floor(i / n_col) * cellSize + (Math.floor(i / n_col)) * gapSize + next_height;
            cur_dataset.push({ type: each_type, x: x, y: y })
        }
        cur_height = (cellSize + gapSize) * n_row; //console.log(cur_height);
        next_height = next_height + cur_height + y_gap;
        big_dataset = big_dataset.concat(cur_dataset);
    }) //end of forEach loop
    // console.log(big_dataset);
    // console.log(row_info);
    return [big_dataset, row_info];
}

function splitCell(data) {
    var dataset = [];
    data.forEach(function (row) {
        splits = row.exploit_type.split(";");
        if (splits.length > 1) {
            splits.forEach(function (s) {
                dataset.push({ year: row.year, exploit_type: s, labour_type: row.labour_type, sex_type: row.sex_type });
            })
        } else {
            dataset.push(row);
        }
    })
    return dataset;
}
function dataProcessor(d) {
    return {
        year: +d["Year of Registration"],
        exploit_type: d["Type Of Exploitation"],
        labour_type: d['Type of Labour'],
        sex_type: d['Type of Sex']
    }
}
function nest_exploitType(data) {
    var nestedData = d3.nest()
        .key(function (d) {
            return d.exploit_type;
        })
        .object(data);
    return nestedData;
}
function nest_labourType(data) {
    var nestedData = d3.nest()
        .key(function (d) {
            return d.labour_type;
        })
        .object(data);
    return nestedData;
}
function nest_sexType(data) {
    var nestedData = d3.nest()
        .key(function (d) {
            return d.sex_type;
        })
        .object(data);
    return nestedData;
}
function yearChange() {
    var select = d3.select('#selectButton_year').node();
    // Get current value of select element
    var selectedOption = select.options[select.selectedIndex].value;
    d3.selectAll(".exploit_chart").remove();
    d3.selectAll(".exploit_label").remove();
    d3.selectAll(".percent_label").remove();
    d3.selectAll(".count_label").remove();
    // d3.selectAll(".arc").remove();

    draw_exploitChart(selectedOption);
}